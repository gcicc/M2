---
title: "**Associations of MARCS `r gsub(x=gsub(x=params$this_endpoint, pattern='All_', replacement='All (tertile) '), pattern='_', replacement=' ')` vs. Clinical Comparators in `r gsub(x=params$study, pattern='_', replacement=' ')`**"
author: "MARCS Crossfunctional Team"
date: last-modified
date-format: "MMM D, YYYY   hh:mm"
format: !include ../../shared-templates/standard-header.yml
params: !include ../../shared-templates/standard-params.yml
execute: !include ../../shared-templates/standard-execute.yml
editor_options: 
  chunk_output_type: console
---

\clearpage

The Takeda MARCS VCE tool is a semi-automated, computer-assisted small intestine villous damage scoring device that provides an effective way to implement the per-frame CE-VAST scale and the per-region MARCS, including the calculation of the individual biomarker outputs, notably BVA using white-light video VCE examinations of patients. The use of this tool is contingent upon the availability of images obtained by a compatible capsule endoscopy device. The tool includes a marking capability that inputs VCE videos and defines regions, which output may then be used by either a manual scoring tool that facilitates manual scoring, or a machine-learning algorithm (with static code) to automate scoring. 

```{=tex}
\begin{figure}
  \caption{Schematic Depiction of the SI and Areas Evaluated by MARCS}
  \centering
  \includegraphics{images/BVA.png}
  \caption*{Burden of Villous Atrophy (BVA) is the mean of the MARCS curve in Tertile 1.}
\end{figure}
```

Validation will be conducted in multiple clinical trials. Specifically, beginning with (i) evaluation of the CE-VAST scale on a per-frame basis, (ii) analytical validation of BVA, and (iii) preliminary assessment of clinical/biological validation, including the analysis on the following study data:

```{=tex}
\begin{figure}
  \caption{Study Calendar}
  \centering
  \includegraphics{images/Study_Design.png}
  \caption*{Scheduled visits identify when data of various types is collected.}
\end{figure}
```

The analysis documented here is also performed on other studies undertaken by the franchise.

\clearpage

```{r analysis, fig.align='center', echo=FALSE, warning=FALSE, error=FALSE}
source(file.path(params$repo_clone, "Shared-Content", "setup-analysis-environment.R"))
analysis_ctx <- setup_analysis_environment(params, "association", "Clinical-Biological-Validation")

# Note: Symptom-window-analyses.R can't be run due to long filenames
# source(path(repo_clone, "Clinical-Biological-Validation", "Deep Dive Symptomatology", "Symptom-window-analyses.R"))

# tictoc::tic() # 4.224 minutes!!!
form_merged_data_sets_output <- form_merged_data_sets(analysis_type=params$analysis_type, study=study, this_endpoint=this_endpoint, output_dir=output_dir)
# tictoc::toc()

lower.triangle_func_results<-lower.triangle_func(df.in=form_merged_data_sets_output$global_analysis_set_out, "ML", this_endpoint)

time.course.plots_results <- time.course.plots(df.in=form_merged_data_sets_output$global_analysis_set_out, reader_type="ML", this_endpoint=this_endpoint)

cor.report.ML <- list()
cor.report.ML.byAggHist <- list()
cor.report.ML.byMO <- list()
cor.report.ML.byqM <- list()
cor.report.ML.byRandStat <- list()
cor.report.ML.byPairing <- list()
cor.report.ML.byArm <- list()

scatterplots.ML <- list()
scatterplots.ML.byAggHist <- list()
scatterplots.ML.byMO <- list()
scatterplots.ML.byqM <- list()
scatterplots.ML.byRandStat <- list()
scatterplots.ML.byPairing <- list()
scatterplots.ML.byArm <- list()

roc.report.ML <- list()
roc.report.ML.byAggHist <- list()
roc.report.ML.byMO <- list()
roc.report.ML.byqM <- list()
roc.report.ML.byRandStat <- list()
roc.report.ML.byPairing <- list()
roc.report.ML.byArm <- list()

roc.figure.ML <- list()
roc.figure.ML.byAggHist <- list()
roc.figure.ML.byMO <- list()
roc.figure.ML.byqM <- list()
roc.figure.ML.byRandStat <- list()
roc.figure.ML.byPairing <- list()
roc.figure.ML.byArm <- list()
sumstats.ML.byARM <- list()
analysis.data.in.ML <- list()
cross.sectional.tests.ML <- list()

cor.report.Human <- list()
cor.report.Human.byAggHist <- list()
cor.report.Human.byMO <- list()
cor.report.Human.byqM <- list()
cor.report.Human.byRandStat <- list()
cor.report.Human.byPairing <- list()
cor.report.Human.byArm <- list()

scatterplots.Human <- list()
scatterplots.Human.byAggHist <- list()
scatterplots.Human.byMO <- list()
scatterplots.Human.byqM <- list()
scatterplots.Human.byRandStat <- list()
scatterplots.Human.byPairing <- list()
scatterplots.Human.byArm <- list()

roc.report.Human <- list()
roc.report.Human.byAggHist <- list()
roc.report.Human.byMO <- list()
roc.report.Human.byqM <- list()
roc.report.Human.byRandStat <- list()
roc.report.Human.byArm <- list()
roc.report.Human.byPairing <- list()

roc.figure.Human <- list()
roc.figure.Human.byAggHist <- list()
roc.figure.Human.byMO <- list()
roc.figure.Human.byqM <- list()
roc.figure.Human.byRandStat <- list()
roc.figure.Human.byPairing <- list()
roc.figure.Human.byArm <- list()
sumstats.Human.byARM <- list()
analysis.data.in.Human<- list()
cross.sectional.tests.Human <- list()

# merged_data_sets is a list containing one entry for each IQ level.
for (i in 1:length(form_merged_data_sets_output$merged_data_sets)) {
  merged_data_set <- form_merged_data_sets_output$merged_data_sets[[i]]
  label.name <- names(form_merged_data_sets_output$merged_data_sets)[i]
  # Set a loop
  for (reader_type in c("ML", "Human")) {
    if (reader_type == "ML") {
      analysis.data.in <- merged_data_set$merged_data.ML$merged_data.ML.full %>% mutate(label.name=label.name)
    } else if (nrow(merged_data_set$merged_data.Human$merged_data.Human.full) > 10) {
      analysis.data.in <- merged_data_set$merged_data.Human$merged_data.Human.full %>% mutate(label.name=label.name)
    } else {
      next
    }

    results <- main_analysis(analysis.data.in=analysis.data.in, reader_type=reader_type, this_endpoint=this_endpoint, runMI = FALSE)

    if (reader_type == "ML") {
      cor.report.ML[[length(cor.report.ML) + 1]] <- results$cor.report
      names(cor.report.ML)[length(cor.report.ML)] <- label.name
      scatterplots.ML[[length(scatterplots.ML) + 1]] <- results$scatterplots
      names(scatterplots.ML)[length(scatterplots.ML)] <- label.name
      roc.report.ML[[length(roc.report.ML) + 1]] <- results$roc.report
      names(roc.report.ML)[length(roc.report.ML)] <- label.name
      roc.figure.ML[[length(roc.figure.ML) + 1]] <- results$roc.figure
      names(roc.figure.ML)[length(roc.figure.ML)] <- label.name
      sumstats.ML.byARM[[length(sumstats.ML.byARM) + 1]] <- results$sumstats
      names(sumstats.ML.byARM)[length(sumstats.ML.byARM)] <- label.name
      analysis.data.in.ML[[length(analysis.data.in.ML) + 1]] <- results$analysis.data
      names(analysis.data.in.ML)[length(analysis.data.in.ML)] <- label.name
      cross.sectional.tests.ML[[length(cross.sectional.tests.ML) + 1]] <- results$cross.sectional.tests
      names(cross.sectional.tests.ML)[length(cross.sectional.tests.ML)] <- label.name
      if (!is.null(results$cor.report.byAggHist)) {
        cor.report.ML.byAggHist[[length(cor.report.ML.byAggHist) + 1]] <- results$cor.report.byAggHist
        names(cor.report.ML.byAggHist)[length(cor.report.ML.byAggHist)] <- label.name
        scatterplots.ML.byAggHist[[length(scatterplots.ML.byAggHist) + 1]] <- results$scatterplots.byAggHist
        names(scatterplots.ML.byAggHist)[length(scatterplots.ML.byAggHist)] <- label.name
        roc.report.ML.byAggHist[[length(roc.report.ML.byAggHist) + 1]] <- results$roc.report.byAggHist
        names(roc.report.ML.byAggHist)[length(roc.report.ML.byAggHist)] <- label.name
        roc.figure.ML.byAggHist[[length(roc.figure.ML.byAggHist) + 1]] <- results$roc.figure.byAggHist
        names(roc.figure.ML.byAggHist)[length(roc.figure.ML.byAggHist)] <- label.name
      }

      if (!is.null(results$cor.report.byMO)) {
        cor.report.ML.byMO[[length(cor.report.ML.byMO) + 1]] <- results$cor.report.byMO
        names(cor.report.ML.byMO)[length(cor.report.ML.byMO)] <- label.name
        scatterplots.ML.byMO[[length(scatterplots.ML.byMO) + 1]] <- results$scatterplots.byMO
        names(scatterplots.ML.byMO)[length(scatterplots.ML.byMO)] <- label.name
        roc.report.ML.byMO[[length(roc.report.ML.byMO) + 1]] <- results$roc.report.byMO
        names(roc.report.ML.byMO)[length(roc.report.ML.byMO)] <- label.name
        roc.figure.ML.byMO[[length(roc.figure.ML.byMO) + 1]] <- results$roc.figure.byMO
        names(roc.figure.ML.byMO)[length(roc.figure.ML.byMO)] <- label.name
      }

      if (!is.null(results$cor.report.byqM)) {
        cor.report.ML.byqM[[length(cor.report.ML.byqM) + 1]] <- results$cor.report.byqM
        names(cor.report.ML.byqM)[length(cor.report.ML.byqM)] <- label.name
        scatterplots.ML.byqM[[length(scatterplots.ML.byqM) + 1]] <- results$scatterplots.byqM
        names(scatterplots.ML.byqM)[length(scatterplots.ML.byqM)] <- label.name
        roc.report.ML.byqM[[length(roc.report.ML.byqM) + 1]] <- results$roc.report.byqM
        names(roc.report.ML.byqM)[length(roc.report.ML.byqM)] <- label.name
        roc.figure.ML.byqM[[length(roc.figure.ML.byqM) + 1]] <- results$roc.figure.byqM
        names(roc.figure.ML.byqM)[length(roc.figure.ML.byqM)] <- label.name
      }
      if (!is.null(results$cor.report.byRandStat)) {
        cor.report.ML.byRandStat[[length(cor.report.ML.byRandStat) + 1]] <- results$cor.report.byRandStat
        names(cor.report.ML.byRandStat)[length(cor.report.ML.byRandStat)] <- label.name
        scatterplots.ML.byRandStat[[length(scatterplots.ML.byRandStat) + 1]] <- results$scatterplots.byRandStat
        names(scatterplots.ML.byRandStat)[length(scatterplots.ML.byRandStat)] <- label.name
        roc.report.ML.byRandStat[[length(roc.report.ML.byRandStat) + 1]] <- results$roc.report.byRandStat
        names(roc.report.ML.byRandStat)[length(roc.report.ML.byRandStat)] <- label.name
        roc.figure.ML.byRandStat[[length(roc.figure.ML.byRandStat) + 1]] <- results$roc.figure.byRandStat
        names(roc.figure.ML.byRandStat)[length(roc.figure.ML.byRandStat)] <- label.name
      }

      if (!is.null(results$cor.report.byPairing)) {
        cor.report.ML.byPairing[[length(cor.report.ML.byPairing) + 1]] <- results$cor.report.byPairing
        names(cor.report.ML.byPairing)[length(cor.report.ML.byPairing)] <- label.name
        scatterplots.ML.byPairing[[length(scatterplots.ML.byPairing) + 1]] <- results$scatterplots.byPairing
        names(scatterplots.ML.byPairing)[length(scatterplots.ML.byPairing)] <- label.name
        roc.report.ML.byPairing[[length(roc.report.ML.byPairing) + 1]] <- results$roc.report.byPairing
        names(roc.report.ML.byPairing)[length(roc.report.ML.byPairing)] <- label.name
        roc.figure.ML.byPairing[[length(roc.figure.ML.byPairing) + 1]] <- results$roc.figure.byPairing
        names(roc.figure.ML.byPairing)[length(roc.figure.ML.byPairing)] <- label.name
      }

      if (!is.null(results$cor.report.byArm)) {
        cor.report.ML.byArm[[length(cor.report.ML.byArm) + 1]] <- results$cor.report.byArm
        names(cor.report.ML.byArm)[length(cor.report.ML.byArm)] <- label.name
        scatterplots.ML.byArm[[length(scatterplots.ML.byArm) + 1]] <- results$scatterplots.byArm
        names(scatterplots.ML.byArm)[length(scatterplots.ML.byArm)] <- label.name
        roc.report.ML.byArm[[length(roc.report.ML.byArm) + 1]] <- results$roc.report.byArm
        names(roc.report.ML.byArm)[length(roc.report.ML.byArm)] <- label.name
        roc.figure.ML.byArm[[length(roc.figure.ML.byArm) + 1]] <- results$roc.figure.byArm
        names(roc.figure.ML.byArm)[length(roc.figure.ML.byArm)] <- label.name
      }  # HUMAN STARTS HERE
    } else {
      cor.report.Human[[length(cor.report.Human) + 1]] <- results$cor.report
      names(cor.report.Human)[length(cor.report.Human)] <- label.name
      scatterplots.Human[[length(scatterplots.Human) + 1]] <- results$scatterplots
      names(scatterplots.Human)[length(scatterplots.Human)] <- label.name
      roc.report.Human[[length(roc.report.Human) + 1]] <- results$roc.report
      names(roc.report.Human)[length(roc.report.Human)] <- label.name
      roc.figure.Human[[length(roc.figure.Human) + 1]] <- results$roc.figure
      names(roc.figure.Human)[length(roc.figure.Human)] <- label.name
      sumstats.Human.byARM[[length(sumstats.Human.byARM) + 1]] <- results$sumstats
      names(sumstats.Human.byARM)[length(sumstats.Human.byARM)] <- label.name
      analysis.data.in.Human[[length(analysis.data.in.Human) + 1]] <- results$analysis.data
      names(analysis.data.in.Human)[length(analysis.data.in.Human)] <- label.name
      cross.sectional.tests.Human[[length(cross.sectional.tests.Human) + 1]] <- results$cross.sectional.tests
      names(cross.sectional.tests.Human)[length(cross.sectional.tests.Human)] <- label.name
      if (!is.null(results$cor.report.byAggHist)) {
        cor.report.Human.byAggHist[[length(cor.report.Human.byAggHist) + 1]] <- results$cor.report.byAggHist
        names(cor.report.Human.byAggHist)[length(cor.report.Human.byAggHist)] <- label.name
        scatterplots.Human.byAggHist[[length(scatterplots.Human.byAggHist) + 1]] <- results$scatterplots.byAggHist
        names(scatterplots.Human.byAggHist)[length(scatterplots.Human.byAggHist)] <- label.name
        roc.report.Human.byAggHist[[length(roc.report.Human.byAggHist) + 1]] <- results$roc.report.byAggHist
        names(roc.report.Human.byAggHist)[length(roc.report.Human.byAggHist)] <- label.name
        roc.figure.Human.byAggHist[[length(roc.figure.Human.byAggHist) + 1]] <- results$roc.figure.byAggHist
        names(roc.figure.Human.byAggHist)[length(roc.figure.Human.byAggHist)] <- label.name
      }

      if (!is.null(results$cor.report.byMO)) {
        cor.report.Human.byMO[[length(cor.report.Human.byMO) + 1]] <- results$cor.report.byMO
        names(cor.report.Human.byMO)[length(cor.report.Human.byMO)] <- label.name
        scatterplots.Human.byMO[[length(scatterplots.Human.byMO) + 1]] <- results$scatterplots.byMO
        names(scatterplots.Human.byMO)[length(scatterplots.Human.byMO)] <- label.name
        roc.report.Human.byMO[[length(roc.report.Human.byMO) + 1]] <- results$roc.report.byMO
        names(roc.report.Human.byMO)[length(roc.report.Human.byMO)] <- label.name
        roc.figure.Human.byMO[[length(roc.figure.Human.byMO) + 1]] <- results$roc.figure.byMO
        names(roc.figure.Human.byMO)[length(roc.figure.Human.byMO)] <- label.name
      }
      if (!is.null(results$cor.report.byqM)) {
        cor.report.Human.byqM[[length(cor.report.Human.byqM) + 1]] <- results$cor.report.byqM
        names(cor.report.Human.byqM)[length(cor.report.Human.byqM)] <- label.name
        scatterplots.Human.byqM[[length(scatterplots.Human.byqM) + 1]] <- results$scatterplots.byqM
        names(scatterplots.Human.byqM)[length(scatterplots.Human.byqM)] <- label.name
        roc.report.Human.byqM[[length(roc.report.Human.byqM) + 1]] <- results$roc.report.byqM
        names(roc.report.Human.byqM)[length(roc.report.Human.byqM)] <- label.name
        roc.figure.Human.byqM[[length(roc.figure.Human.byqM) + 1]] <- results$roc.figure.byqM
        names(roc.figure.Human.byqM)[length(roc.figure.Human.byqM)] <- label.name
      }
      if (!is.null(results$cor.report.byRandStat)) {
        cor.report.Human.byRandStat[[length(cor.report.Human.byRandStat) + 1]] <- results$cor.report.byRandStat
        names(cor.report.Human.byRandStat)[length(cor.report.Human.byRandStat)] <- label.name
        scatterplots.Human.byRandStat[[length(scatterplots.Human.byRandStat) + 1]] <- results$scatterplots.byRandStat
        names(scatterplots.Human.byRandStat)[length(scatterplots.Human.byRandStat)] <- label.name
        roc.report.Human.byRandStat[[length(roc.report.Human.byRandStat) + 1]] <- results$roc.report.byRandStat
        names(roc.report.Human.byRandStat)[length(roc.report.Human.byRandStat)] <- label.name
        roc.figure.Human.byRandStat[[length(roc.figure.Human.byRandStat) + 1]] <- results$roc.figure.byRandStat
        names(roc.figure.Human.byRandStat)[length(roc.figure.Human.byRandStat)] <- label.name
      }

      if (!is.null(results$cor.report.byPairing)) {
        cor.report.Human.byPairing[[length(cor.report.Human.byPairing) + 1]] <- results$cor.report.byPairing
        names(cor.report.Human.byPairing)[length(cor.report.Human.byPairing)] <- label.name
        scatterplots.Human.byPairing[[length(scatterplots.Human.byPairing) + 1]] <- results$scatterplots.byPairing
        names(scatterplots.Human.byPairing)[length(scatterplots.Human.byPairing)] <- label.name
        roc.report.Human.byPairing[[length(roc.report.Human.byPairing) + 1]] <- results$roc.report.byPairing
        names(roc.report.Human.byPairing)[length(roc.report.Human.byPairing)] <- label.name
        roc.figure.Human.byPairing[[length(roc.figure.Human.byPairing) + 1]] <- results$roc.figure.byPairing
        names(roc.figure.Human.byPairing)[length(roc.figure.Human.byPairing)] <- label.name
      }

      if (!is.null(results$cor.report.byArm)) {
        cor.report.Human.byArm[[length(cor.report.Human.byArm) + 1]] <- results$cor.report.byArm
        names(cor.report.Human.byArm)[length(cor.report.Human.byArm)] <- label.name
        scatterplots.Human.byArm[[length(scatterplots.Human.byArm) + 1]] <- results$scatterplots.byArm
        names(scatterplots.Human.byArm)[length(scatterplots.Human.byArm)] <- label.name
        roc.report.Human.byArm[[length(roc.report.Human.byArm) + 1]] <- results$roc.report.byArm
        names(roc.report.Human.byArm)[length(roc.report.Human.byArm)] <- label.name
        roc.figure.Human.byArm[[length(roc.figure.Human.byArm) + 1]] <- results$roc.figure.byArm
        names(roc.figure.Human.byArm)[length(roc.figure.Human.byArm)] <- label.name
      }
    }
  } # ML or Human
} # for each IQ level
```



\clearpage


## Executive Summary for Machine Learning Reads

Starting from the definition of Clinical/Biological Validation: Assessing a test’s “ability to accurately and reliably predict the clinically defined disorder or phenotype of interest,” we estimate early associations of `r gsub(x=this_endpoint, pattern='_', replacement=' ')` to the currently proposed parameters of histologic and symptomatologic assessments of celiac disease activity. The primary analysis result uses the non-parametric Spearman correlation.

Whereas the essence of clinical validation is to document relationships, it is noted that perfect correlations with histology or symptoms are neither expected nor even considered to be ideal given that MARCS can assess regions not generally accessible to histology and at a biologically more specific level than symptomatology.

```{r executive-summary.ML, fig.align='center', echo=FALSE}
generate_exec_assoc_metrics(analysis_output.in=cor.report.ML)
```


\clearpage


### Views to Support Actionable Insights
```{r lower-triang, fig.width=6, fig.height=3, fig.align='center', echo=FALSE}
generate_lower_triangle(lower.triangle_func_results$lower.triangle, "Pooled")
```
```{r variable-distributions, fig.width=6, fig.height=5, fig.align='center', echo=FALSE}
generate_variable_distributions_plot(form_merged_data_sets_output$global_analysis_set_out)[[1]]

```

\clearpage

```{r}
generate_variable_distributions_plot(form_merged_data_sets_output$global_analysis_set_out)[[2]]
```

\clearpage


```{r time-course-plots, fig.width=6.5, fig.height=8, fig.align='center', echo=FALSE}
time.course.plots_results
```


\clearpage

## Analysis Details

### Association Expressed by Correlation

The primary analysis result uses the non-parametric Spearman correlation. For completeness, we also add detailed results in terms of the parametric Pearson correlation, and a non-parametric generalization of ROC analysis when the clinical marker is not binary scale as described by Obuchowski.

```{r Correlation.details.ML, fig.align='center', echo=FALSE}
generate_assoc_metrics(analysis_output.in=cor.report.ML)
```
```{r scatterplot.grid.ML, fig.width=6, fig.height=6, fig.align='center', echo=FALSE}
temp <- generate_scatterplots(scatterplots=scatterplots.ML, "ML")
plot(temp[[2]])
```


\clearpage


### Association Expressed by Generalized ROC
```{r roc.table.out.ML, fig.align='center', echo=FALSE}
generate_roc_table(analysis_output.in=roc.report.ML) 
```
```{r roc.figure.ML, fig.width=6, fig.height=6, fig.align='center', echo=FALSE}
temp <- generate_roc_figure(roc.figure.ML, "ML")
plot(temp[[2]])
```


\clearpage


## Stratified Analyses

### by Aggregate Histology
```{r cor.report.table.ML.byAggHist, fig.align='center', echo=FALSE}
cor_report_stratified.forPDF <- generate_exec_cor_report_stratified(analysis_output.in=cor.report.ML.byAggHist, reader_type="ML", stratifier="AggHist")
if (!is.null(cor_report_stratified.forPDF)) {
  cat("More vs. Less Diseased signifies above or below the median aggregate histology value.")
  cor_report_stratified.forPDF
}
```
```{r scatterplot.grid.byAggHist, fig.width=6, fig.height=6, fig.align='center', echo=FALSE}
if (!is.null(cor_report_stratified.forPDF)) {
  generate_scatterplots_stratified(scatterplots=scatterplots.ML.byAggHist, "ML", "AggHist")
}
```
```{r cor.report.table.ML.byAggHist-empty, fig.align='center', echo=FALSE}
if (is.null(cor_report_stratified.forPDF)) {
  cat("Stratification by Aggregate Histology type not possible on the basis of available study data.")
}
```


\clearpage


### by Marsh-Oberhuber Type
```{r cor.report.tab.ML.byMO, fig.align='center', echo=FALSE}
cor_report_stratified.forPDF <- generate_exec_cor_report_stratified(analysis_output.in=cor.report.ML.byMO, reader_type="ML", stratifier="MO")
if (!is.null(cor_report_stratified.forPDF)) {
  cor_report_stratified.forPDF
}
```

```{r scatterplot.grid.byMO, fig.width=6, fig.height=6, fig.align='center', echo=FALSE}
if (!is.null(cor_report_stratified.forPDF)) {
  generate_scatterplots_stratified(scatterplots=scatterplots.ML.byMO, "ML", "MO")
}
```
```{r cor.report.table.ML.byMOempty, fig.align='center', echo=FALSE}
if (is.null(cor_report_stratified.forPDF)) {
  cat("Stratification by Marsh-Oberhuber type not possible on the basis of available study data.")
}
```


### by Quantitative Marsh Type
```{r cor.report.table.ML.byqM, fig.align='center', echo=FALSE}
cor_report_stratified.forPDF <- generate_exec_cor_report_stratified(analysis_output.in=cor.report.ML.byqM, reader_type="ML", stratifier="qM")
if (!is.null(cor_report_stratified.forPDF)) {
  cor_report_stratified.forPDF
}
```

```{r scatterplot.grid.byqM, fig.width=6, fig.height=6, fig.align='center', echo=FALSE}
if (!is.null(cor_report_stratified.forPDF)) {
  generate_scatterplots_stratified(scatterplots=scatterplots.ML.byMO, "ML", "MO")
}
```
```{r cor.report.table.ML.byqM-empty, fig.align='center', echo=FALSE}
if (is.null(cor_report_stratified.forPDF)) {
  cat("Stratification by Quantitative Marsh type not possible on the basis of available study data.")
}
```


\clearpage


### by Randomization Status
```{r cor.report.table.ML.byRandStat, fig.align='center', echo=FALSE}
cor_report_stratified.forPDF <- generate_exec_cor_report_stratified(analysis_output.in=cor.report.ML.byRandStat, reader_type="ML", stratifier="RandStat")
if (!is.null(cor_report_stratified.forPDF)) {
  cor_report_stratified.forPDF
}
```
```{r scatterplot.grid.byRandStat, fig.width=6, fig.height=6, fig.align='center', echo=FALSE}
if (!is.null(cor_report_stratified.forPDF)) {
  generate_scatterplots_stratified(scatterplots=scatterplots.ML.byRandStat, "ML", "RandStat")
}
```
```{r cor.report.table.ML.byRandStat-empty, fig.align='center', echo=FALSE}
if (is.null(cor_report_stratified.forPDF)) {
  cat("Stratification by randomization status not possible on the basis of available study data.")
}
```


\clearpage

### by Visit
```{r cor.report.table.ML.byPairing, fig.align='center', echo=FALSE}
cor_report_stratified.forPDF <- generate_exec_cor_report_stratified(analysis_output.in=cor.report.ML.byPairing, reader_type="ML", stratifier="Pairing")
if (!is.null(cor_report_stratified.forPDF)) {
  cor_report_stratified.forPDF
}
```
```{r scatterplot.grid.byPairing, fig.width=6, fig.height=6, fig.align='center', echo=FALSE}
if (!is.null(cor_report_stratified.forPDF)) {
  generate_scatterplots_stratified(scatterplots=scatterplots.ML.byPairing, "ML", "Pairing")
}
```
```{r cor.report.table.ML.byPairing-empty, fig.align='center', echo=FALSE}
if (is.null(cor_report_stratified.forPDF)) {
  cat("Stratification by visit not possible on the basis of available study data.")
}
```

\clearpage
### by Arm
```{r cor.report.table.ML.byArm, fig.align='center', echo=FALSE}
cor_report_stratified.forPDF <- generate_exec_cor_report_stratified(analysis_output.in=cor.report.ML.byArm, reader_type="ML", stratifier="Arm")
if (!is.null(cor_report_stratified.forPDF)) {
  cor_report_stratified.forPDF
}
```
```{r scatterplot.grid.byArm, fig.width=6, fig.height=6, fig.align='center', echo=FALSE}
if (!is.null(cor_report_stratified.forPDF)) {
  generate_scatterplots_stratified(scatterplots=scatterplots.ML.byArm, "ML", "Arm")
}
```
```{r cor.report.table.ML.byArm-empty, fig.align='center', echo=FALSE}
if (is.null(cor_report_stratified.forPDF)) {
  cat("Stratification by arm not possible on the basis of available study data.")
}
```

## Summary Stats by Arm

```{r plot_density_stats, fig.width=6.5, fig.height=8, fig.align='center', echo=FALSE}
plot2 <- plot_density_stats(data.in = analysis.data.in.ML)
plot2[[2]]
```


\clearpage

```{r echo=FALSE}
# This is too long... needs to be broken up
sumstats <- sumstats.report(data.in=sumstats.ML.byARM) 
sumstats[[1]]
```


\clearpage

```{r echo=FALSE}
sumstats[[2]]
```


\clearpage

```{r echo=FALSE}
sumstats[[3]]
```


\clearpage

```{r plot_summary_stats, fig.width=6.5, fig.height=8, fig.align='center', echo=FALSE}
plot1 <- plot_summary_stats(data.in = sumstats.ML.byARM)
plot1[[2]]
```

```{r cross.section.comparison.plots, fig.width=6.5, fig.height=8, fig.align='center', echo=FALSE}
plot3<-cross.section.comparison.plots(data.in = cross.sectional.tests.ML)
plot3[[2]]
```

<!-- 
NO HUMAN FOR NOW \clearpage
## Analyses for Human Readers
```{r executive-summary.Human, fig.align='center', echo=FALSE}
forPDF <- generate_exec_assoc_metrics(analysis_output.in=cor.report.Human)
if (!is.null(forPDF)) {
  forPDF
} else {
  cat("Human reader analyses not possible on the basis of available study data.")
}
```
-->


\clearpage

## Demographic Make-up for Subjects in this Slice
```{r subject-counts, fig.align='center', echo=FALSE}
write.csv(form_merged_data_sets_output$counts, file=path(table_path, "subject_counts.csv"))
subject.counts <- form_merged_data_sets_output$counts %>%
  gt() %>%
  tab_header(title="Counts of Subjects and Observations")
gt::gtsave(subject.counts, filename=path(table_path, "subject_counts.formatted.png"))
subject.counts
```
```{r demographics, fig.align='center', echo=FALSE}
form_merged_data_sets_output$demographics %>% as_gt() %>%
  cols_width(everything() ~ px(90))
```


\clearpage

## Appendix A: Method to Compute the Latent True Disease Burden from  Multiple Clinical Markers {.unnumbered}
This analysis acknowledges the current status regarding multiple observable but individually imperfect clinical markers representing differing aspects of the disease. As means to elucidate a latent disease burden measure to reflect the severity of disease more robustly than any of the individual markers by combining multiple observables. To make this concrete, three composites are utilized: 

   - a principal components analysis (PCA) of Vh:Cd, IEL count, and GISS, called "Disease Burden" which seeks to represent both histology and symptoms
   - another PCA-based measure called "Aggregate Histology" that omits the GISS
   - a relatively simple combination of Vh:Cd and IEL count called "VCIEL"

While these are being developed, our aim is to arrive at a potentially more informative marker that avoids over-reliance on any of the imperfect single variables and thereby provide a better comparison to MARCS scores.

More detail will be added as this method is further developed based on clinical and biological insights into histology and symptomatology, and serology.

\clearpage

## Appendix B: Provenance {.unnumbered}
```{r provenance, fig.align='center', echo=FALSE}
cat(paste("Analysis executed by", system2("whoami", stdout=TRUE, stderr=TRUE)))
cat(str_wrap(paste("Results derived from", form_merged_data_sets_output$provenance), width=50, whitespace_only=FALSE))
setwd(repo_clone)
cat(str_wrap(paste("Code used for analysis was", git2r::status(repo=".", staged=TRUE, unstaged=TRUE, untracked=TRUE, ignored=FALSE, all_untracked=FALSE)), width=50, whitespace_only=FALSE))
```
